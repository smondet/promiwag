
To do:


* Automata_generator:
  ? 'more lazy' binary tree of (condition, statement_then), with special
    case for unknown protocols. Then balance the binary tree and
    generate if-then-else's.
  - separate protocol description from compilation (e.g. atomic_transition)
    => module Meta_protocol and Protocol_automaton_generator
    or Meta_packet + Meta_protocol  Packet_parsing Protocol_automaton (?)

* Pcap:
  - version which takes STIEL as input (?)
  - version with the main

* Promiwag_standard_protocols: 
  - TCP packets

* Promiwag_stiel.Verify:
  - recursivity for variables (that's an environment check)
  - variables defined twice
  - retrive checks to do on buffer accesses, and divisions by zero
  - typing of variable assignments (follow types of declared
    variables, and check assignments)

* Promiwag_stiel: Integer management
  - module SafeInt64, with all bounds checkings
  - check that ints are positive

* Promiwag_stiel: Language
  ? add the "Exception" int,bool expressions (?)
  - pure functions and call in expressions
  - procedures  and call statement
  - external procedures, defined with functions to transform parameters
  - Write_{int,...}_to_buffer i.e. a controled/typed asignement of *buffer.
  - big2little and little2big
  - log: user-defined printers: 
    e.g.: ("@ip_addr", "%d.%d.%d.%d", fun te -> [ te[0], ... ])
    ? but format independent of 'C', like "@int.@int.@int.@int" ???
    -> then need a @0int and a @0hex format ?

* Promiwag_stiel: Future
  - full interpreter
  - export to Coq or ?
  - float expressions

* use Format, or EasyFormat for printing C and Stiel


? Promiwag_platform: Generate an "inspector.c" piece of code which
  retrives endianism, sizeof's, etc ... as OCaml code ...

